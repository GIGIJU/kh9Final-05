<?xml version="1.0" encoding="UTF-8"?>

<!-- mapper 파일은 특정 테이블에 대한 SQL 구문을 보관하는 파일이다 - myBatis를 이용하는 개발자는 이곳에 저장된 
	SQL 구문을 "아이디"를 이용해서 호출한다 - 파일마다 동일한 아이디로 인해 발생하는 충돌을 방지하기 위해 고유한 namespace를 
	사용한다 - 만약 namespace가 olympic이고 구문 ID가 list라면 외부에서는 olympic.list로 호출한다 - 일반적으로 
	namespace는 테이블명으로 한다! - mapper 내부에는 다음 종류 태그로 구문을 저장할 수 있다. - <insert> - 
	<select> - <update> - <delete> - 각 구문은 반드시 아이디를 가져야 한다. - 각 구문에는 다음과 같은 속성을 
	작성할 수 있다 - parameterType : 해당 구문이 실행되기 위해 필요한 데이터의 자료형(1개만 작성 가능, 선택) - resultType 
	: 해당 구문의 실행 결과를 변환하기 위한 자료형(1개만 작성 가능, 필수) - (주의) List이든 아니든 DTO의 형태를 작성한다(모르는 
	부분을 알려준다) - 각 구문에는 데이터를 다음과 같이 바인딩할 수 있다 - 정적 바인딩 : ${이름} 형태로 작성하면 어떠한 추가 
	작업도 없이 해당 위치에 데이터가 그대로 작성된다 - 동적 바인딩 : #{이름} 형태로 작성하면 자동으로 자료형에 맞게 해당 데이터를 
	추출하여 작성해준다(DTO 변수명) -->

<!DOCTYPE mapper
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="teetime">

	<select id="list" parameterType="BookingComplexSearchVO" resultType="TeeTimeListVO">
		<bind name="fieldAreaExist" value="fieldArea != null and !fieldArea.equals('')"/> 
		select G.field_no, G.field_name, G.field_greenfee, B.course_name, B.tee_time_t, B.part_time, B.tee_time_no from golf_field G left outer join
		(
		select * from golf_course C inner join 
		(
		select T.tee_time_no,T.course_no,T.tee_time_t,T.part_time,B.booking_date from tee_time T 
		left outer join (select * from booking where tee_time_d= #{teeTimeD}) B 
		on T.tee_time_no = B.tee_time_no where B.booking_date is null
		) B on B.course_no = C.course_no
		) B on B.field_no = G.field_no
		<where>
	 			 and tee_time_t is not null 
	 			 and G.field_no = #{fieldNo}
				<if test="partTime > 0">
					and part_time = #{partTime}
				</if>
				<if test="fieldAreaExist">
					and field_area = #{fieldArea}
				</if>
	 			<if test="fieldGreenfee > 0">
				<![CDATA[
					and field_greenfee <= #{fieldGreenfee}
				]]>
				</if>
			</where> 
 		order by field_no, tee_time_t
	</select>
	
	<select id="list2" parameterType="Map" resultType="TeeTimeListVO">
		select G.field_no, G.field_name, G.field_greenfee, B.course_name, B.tee_time_t, B.part_time, B.tee_time_no from golf_field G left outer join
		(
		select * from golf_course C inner join 
		(
		select T.tee_time_no,T.course_no,T.tee_time_t,T.part_time,B.booking_date from tee_time T 
		left outer join (select * from booking where tee_time_d= #{teeTimeD}) B 
		on T.tee_time_no = B.tee_time_no where B.booking_date is null
		) B on B.course_no = C.course_no
		) B on B.field_no = G.field_no
	 			 where tee_time_t is not null 
	 			 and G.field_no = #{fieldNo}
		order by field_no, tee_time_t
	</select>

	<select id="one" parameterType="int" resultType="Teetime1VO">
		select * from
		tee_time_1 where tee_time_no = #{teeTimeNo}
	</select>

	<select id="sequence" resultType="int">
		select tee_time_seq.nextval
		from dual
	</select>

	<insert id="insert" parameterType="TeetimeDto">
		insert into
		tee_time(tee_time_no,course_no,tee_time_t,part_time)
		values(#{teeTimeNo},#{courseNo},#{teeTimeT},#{partTime})
	</insert>


	<resultMap type="GolfFieldBookingVO" id="feildMap">
		<!-- 객체에 대한 매핑 설정 : association -자료형은 변수에 맞게 자동 변환되며 불가능할 경우 -->
		<association property="golfFieldDto" javaType="GolfFieldDto">
			<result column="field_no" property="fieldNo" />
			<result column="field_name" property="fieldName" />
			<result column="field_post" property="fieldPost" />
			<result column="field_basic_adress" property="fieldBasicAdress" />
			<result column="field_detail_adress" property="fieldDetailAdress" />
			<result column="field_info" property="fieldInfo" />
			<result column="field_Phone" property="fieldPhone" />
			<result column="field_caddiefee" property="fieldCaddiefee" />
			<result column="field_cartfee" property="fieldCartfee" />
			<result column="field_greenfee" property="fieldGreenfee" />
			<result column="field_openday" property="fieldOpenday" />
			<result column="field_people" property="fieldPeople" />
			<result column="field_prepay" property="fieldPrepay" />
			<result column="field_commission" property="fieldCommission" />
			<result column="field_area" property="fieldArea" />
		</association>
		<!-- 컬렉션(List<paymentDetailDto>)에 대한 매핑 설정 : collection -컬렉션 자료형을 두 가지로 
			설정해야 한다 -javaType : 컬렉션의 자료형 -ofType : 내용물의 자료형(Generic type) -내부에는 객체처럼 
			result를 이용하여 매핑을 수행한다 -(반드시)해당 컬렉션을 채우기 위해 필요한 select 구문의 id를 지정해야 한다(select,columnx) -->
		<collection property="timeList" javaType="List" ofType="BookingSearchListVO" select="treeSearchSubquery" column="field_no">
			<result column="field_no" property="fieldNo" />
			<result column="field_name" property="fieldName" />
			<result column="field_greenfee" property="fieldGreenfee" />
			<result column="course_name" property="courseName" />
			<result column="tee_time_t" property="teeTimeT" />
			<result column="part_time" property="partTime" />
			<result column="tee_time_no" property="teeTimeNo" />
		</collection>
	</resultMap>

	<select id="treeSearch" resultMap="feildMap">
		select * from golf_field 
	</select>
	<select id="treeSearchSubquery" resultType="BookingSearchListVO" parameterType="int">
		select 
			G.field_no, G.field_name, G.field_greenfee, B.course_name,
			B.tee_time_t, B.part_time, B.tee_time_no,B.part_time 
		from golf_field G
			left outer join
			(
				select * from golf_course C inner join(
					select T.tee_time_no,T.course_no,T.tee_time_t,T.part_time,B.booking_date
					from tee_time T
					left outer join (
							select * from booking where tee_time_d= '2022-07-04'
					) B
					on T.tee_time_no = B.tee_time_no where B.booking_date is null
			) B on B.course_no = C.course_no
		) B on B.field_no = G.field_no where tee_time_t is not null and G.field_no =#{fieldNo}
		order by field_no, tee_time_t
	</select>
	
	<!-- 
		원하는 것
		- 검색어(지역, 날짜, 시간대, 가격)을 입력하면 조회되도록 구문을 만드는 것
			- 지역(fieldArea), 날짜(teeTimeD), 시간대(PartTime), 가격대(fieldGreenFee)
		- 필요한 테이블 : gold_fild(골프장), golf_course(골프코스), tee_time(시간표), booking(예약)		
	 	- 검색항목에 따라 예약이 안된 목록이 시간대별로 출력
	 -->
</mapper> 







